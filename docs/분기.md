#### Truthy & Falsy

```js
function printName(name) {
  if (name === undefined || name === null) {
    // if(name) 인 경우에도 동일한 결과 출력
    return "사람이 없네요";
  }

  return "안녕하세요 " + name + "님";
}
```

#### 단축 평가

`state.data ? state.data : 'fear'`를 간단하게 `state.data || 'fear`로 표현할 수 있다.

```js
function favoriteDog(someDog) {
  let favoriteDog;

  if (someDog) {
    favoriteDog = dog;
  } else {
    favoriteDog = "냐옹";
  }

  return favoriteDog + "입니다";
}
```

```js
// 대신 단축 평가를 사용할 경우
function favoriteDog(someDog) {
  return (someDog || "냐옹") + "입니다";
}

favoriteDog(); // 나용이 호출된다.
```

---

```js
function getActiveUserName(user, isLogin) {
	if (isLogin) {
  if(user)
		if (user.name) {
			return user.name;
		} else {
			return '이름없음';
		}
	}
  }
}
```

```js
function getActiveUserName(user, isLogin) {
  if (isLogin && user) {
    if (user.name) {
      return user.name;
    } else {
      return "이름없음";
    }
  }
}
```

```js
function getActiveUserName(user, isLogin) {
  if (isLogin && user) {
    return user.name || "이름없음";
  }
}
```

줄일 수 있다.

#### else 피하기

else를 사용하지 않아도 되는 경우 생략하기.

#### Early Return

```js
function loginService(isLogin, user) {
  if (!isLogin) {
    if (checkToken()) {
      if (!user.nickName) {
        return registerUser(user);
      } else {
        refreshToken();

        return "로그인 성공";
      }
    } else {
      throw new Error("No Token");
    }
  }
}
```

에서 early return를 사용하면

```js
function loginService(isLogin, user) {
  if (isLogin) {
    return;
  }

  if (!checkToken()) {
    return new Error("no token");
  }

  if (!user.nickName) {
    return registerUser(user);
  }

  login();
}
```

이렇게 코드를 분리하면 로직이 간단하다.

#### 부정 조건문 지양하기

`if(!false)`와 같이 부정 조건문을 사용하는 것은 지양하다. => 실수할 가능성이 크다.

예외는

1. early return
2. form validation
3. 보안 혹은 검사하는 로직

#### Default Case 고려하기

```js
function sum(x, y) {
  return x + y;
}

sum(100, 200);
```

에서

```js
function sum(x, y) {
  x = x || 1;
  y = y || 1;
  return x + y;
}

sum(100, 200);
```

---

```js
function createElement(type, height, width) {
  const element = document.createElement(type);

  element.style.height = height;
  element.style.width = width;

  return element;
}
```

에서

```js
function createElement(type, height, width) {
  const element = document.createElement(type);

  element.style.height = height || 100;
  element.style.width = width || 100;

  return element;
}
```

---

```js
function registerDay(userInputDay) {
  switch (userInputDay) {
    case "월요일": // some code
    case "화요일": // some code
    case "수요일": // some code
    case "목요일": // some code
    case "금요일": // some code
    case "토요일": // some code
    case "일요일": // some code
  }
}
```

=>

```js
function registerDay(userInputDay) {
  switch (userInputDay) {
    case "월요일": // some code
    case "화요일": // some code
    case "수요일": // some code
    case "목요일": // some code
    case "금요일": // some code
    case "토요일": // some code
    case "일요일": // some code
    default:
      throw Error("입력값이 유효하지 않습니다.");
  }
}
```

---

이처럼 default case를 작성해주도록 하자.

#### 명시적인 연산자 사용 지향하기

연산자 우선순위를 암기하기 보다는

```js
if((isLogin && token) || user)
```

처험 사람이 보기 편하게 우선순위를 지정하자.

#### Nullish coalescing operator ??

`??`은 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고 그렇지 않으면 좌항의 피연산자를 반환한다. `||`는 falsy 값으로 평가되는 값을 false로
반환하지만 `??`은 null 또는 undefined인 경우에만 반환한다.

```javascript
// 좌항의 피연산자가 null 또는 undefined이면 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.
var foo = null ?? "default string";
console.log(foo); // "default string"
```

=> null과 undefined를 판단할 때만 사용해야 한다.

---

```js
/**
 * @see - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator#no_chaining_with_and_or_or_operators
 */
function getUserName(isLogin, user) {
  return isLogin && user ?? user.name;
}
```

다음과 같은 경우 에러가 발생한다. 이를

```js
/**
 * @see - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator#no_chaining_with_and_or_or_operators
 */
function getUserName(isLogin, user) {
  return (isLogin && user) ?? user.name;
}
```

로 수정하면 에러가 발생하지 않는다. NULL 병합 연산자 같은 경우 우선순위가 낮은데 실수를 방지하기 위해서 에러를 발생시킨다.
