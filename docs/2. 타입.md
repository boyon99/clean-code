#### 타입 검사

- 일반적으로 `typeof` 연산자를 사용하나 원시 타입의 경우 괜찮으나 참조 타입(동적으로 변하는 언어니기 때문에 타입까지 동적으로 변하기 때문)의 경우에는 정확하게 출력되지 않는다. 하여 `instanceof`를 사용한다.

```js
typeof null; // object - 오류가 맞다.

arr instanceof Array; // true
arr instanceof Object; // true (프로토타입 체인을 타고 위로 올라가면 true가 된다)
```

- `Object.prototype.toString.call(data)` 식으로도 검색 가능하다.

=> 항상 검색할 때는 주의가 필요하다. 해서 구글에 검색하며 찾아보자 `javascript is string`

#### undefined & null

```js
!null; // true
!!null; // false

// null => math => 0
null + 123; // 123

// 선언되었지만 값은 정의되지 않고 할당 X
let varb;
typeop varb // undefined

undefined + 10 // NaN

!undefined // true

```

- `undefined`의 값은 NaN이고 null의 값은 0이다
- `undefined`의 타입은 undefined이고 null의 타입은 객체이다
  > 둘 중 하나의 값만 정하는 컨벤션이 있으면 좋음

#### eqeq (==) 줄이기

`==` 대신 ``===`를 사용하자. `==`를 사용하는 경우 타입 캐스팅이 발생한다.

> https://dorey.github.io/JavaScript-Equality-Table/

#### 형변환 주의하기

```js
if (!false) console.log(false + " is falsy value");
if (!undefined) console.log(undefined + " is falsy value");
if (!null) console.log(null + " is falsy value");
if (!0) console.log(0 + " is falsy value");
if (!NaN) console.log(NaN + " is falsy value");
if (!"") console.log("" + " is falsy value");
```

#### isNaN

```js
isNaN(123 + "test"); // true => 느슨한 검사
Number.isNaN(123 + "test"); // false => 엄격한 검사
```

isNaN 검사 시 엄격한 검사를 하기 위해서는 `Number.isNaN()`를 하는 것이 좋다.
